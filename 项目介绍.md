# 项目介绍

## `SimpleRPC`框架： 

1. Simple RPC 是面向接口的远程方法调用的框架，提供服务的自动注册与发现机制，实现了 RPC的基本功能：包括 注册中心、网络传输、动态代理、序列化/反序列化、传输协议以及负载均衡等等。
2. 特点：
   - 可扩展性较好， `ExtensionLoader`，并且不依赖于 Spring 管理 Bean
   - 可以使用注解来开发，比较简单方便

3. 比较好的点：
   - 支持服务自动注册、注解开发 —— Spring 的动态 bean 的注册，以及 BeanPostProcessor接口 
   - 优化了客户端与服务端的连接问题，解决了 粘包和半拆包问题，利用心跳机制维持长连接
   - 利用CompletableFuture 优化接收服务端的响应结果
   - 大量运用缓存思想：复用Channel, 维持长连接, 
4. 做的一些优化：

-  **使用 Netty（基于 NIO）替代 BIO 实现网络传输；**
-  **使用开源的序列化机制 Prostuff（也可以用其它的）替代 JDK 自带的序列化机制；**
-  **使用 Zookeeper 管理相关服务地址信息** —— 事件监听机制：在服务端设置Hook，， 在Client端第一次连接ZK的时候，注册监听
-  Netty 重用 Channel 避免重复连接服务端 —— ChannelProvider
-  使用 `CompletableFuture` 包装接受客户端返回结果（之前的实现是通过 `AttributeMap` 绑定到 Channel 上实现的） 详见：[使用 CompletableFuture 优化接受服务提供端返回结果](https://github.com/Snailclimb/guide-rpc-framework/blob/master/docs/使用CompletableFuture优化接受服务提供端返回结果.md)
-  **增加 Netty 心跳机制** : 保证客户端和服务端的连接不被断掉，避免重连。
-  **客户端调用远程服务的时候进行负载均衡** ：调用服务的时候，从很多服务地址中根据相应的负载均衡算法选取一个服务地址。ps：目前实现了随机负载均衡算法与一致性哈希算法。（轮询）
-  **处理一个接口有多个类实现的情况** ：对服务分组，发布服务的时候增加一个 group 参数即可。
-  **集成 Spring 通过注解注册服务**
-  **集成 Spring 通过注解进行服务消费** 。参考： [PR#10](https://github.com/Snailclimb/guide-rpc-framework/pull/10)
-  **增加服务版本号** ：建议使用两位数字版本，如：1.0，通常在接口不兼容时版本号才需要升级。为什么要增加服务版本号？为后续不兼容升级提供可能，比如服务接口增加方法，或服务模型增加字段，可向后兼容，删除方法或删除字段，将不兼容，枚举类型新增字段也不兼容，需通过变更版本号升级。
-  **对 SPI 机制的运用** 
-  **增加可配置比如序列化方式、注册中心的实现方式,避免硬编码** ：通过 API 配置，后续集成 Spring 的话建议使用配置文件的方式进行配置
-  客户端与服务端通信协议（数据包结构）重新设计
-  **编写测试为重构代码提供信心**
-  **服务监控中心（类似dubbo admin）**
-  **设置 gzip 压缩**

5. 后续待优化点：
   - 支持可配置化，可以利用 Spring  或者 自己实现一套 读取配置文件（已经实现了）
   - 扩展更多的功能，比如 负载均衡策略 —— 一致性 hash， 序列化方式， 支持不同的协议，如UDP
   - 需要更好的容错机制
   - 增加监控、管理这方面的功能
   
     



## 实习项目

1. 利用 ES优化查询

   需求： 目前工作台页面查询速度很缓慢，基本上都要1.8-9秒才会加载完毕，而加上新的需求——新的权限之后，只会雪上加霜，所以我们有考虑需要去优化这个查询。

   但是由于业务需要，SQL已经难以去做优化了，因为它涉及到多张表、很多关联字段的复合查询问题；

   而且过滤条件还是动态多变的

   有两种解决办法：1）修改底层数据模型，使得避免使用并表查

   ​                               2）在业务层过滤掉复杂查询，使得DAO层只要做简单查询就可以了

   ElasticSearch 是一个开源的使用 Java 做的搜索引擎，建立在一个全文搜索引擎库 Apache Lucene基础上，它内部使用Lucene做索引与搜索，但它是的目的是使全文检索变得简单，通过隐藏 Lucense的复杂性，取而代之的是提供一套简单一致的 RESTful API

   我们利用 ES 是为了使用 它强大的搜索能力（倒排索引）来简化复杂SQL的查询，因此我们还需要利用它的强大的分布式的实时文档存储能力 + 分布式实时分析搜索引擎。

   如果我们要利用ES来做复杂查询，那必须保证它和数据库的一致性，老数据好办直接推上去就可以，问题是数据在不断修改和产生的，如何保障它的实时性

   - 数据不一致问题：
     1. 在所有修改表的地方都去增加逻辑，往ES上推，但是这个显然一个是几乎又要改动大量了的代码，另一个是我们要做的这个需求对实时性要求没有那么精确
     2. 利用MySQL 主从同步的特点，我们监听数据库变更，每当有我们关注的表和需要监听的列有变动，就给我们发消息，然后消费消息同步到ES中，这样能保证实时嘛？不太行，有1s左右的时延，因此在查询的时候不能依赖于ES的查询，我们还需要到数据库再查一遍，但是这个时候范围已经缩得很小了，不用再全表查

   - 搜索问题：虽然我们尽力去解决这个问题，但是还有将近1s的gap， ES中的数据不可靠，如何解决
     - 对于删除、修改状态的：ES返回的是无效的、失效的，利用 ES去得到一个很小的范围，几乎就是精确的，然后再去数据库中取，做状态和条件的校验
     - 但是对于新增的几乎就无能为力了嘛？ES缺少部分数据。
     - 也不是，我们采用了一个方式，如果时间间隔超过了1s，

   - 学习了 ES 的使用，利用ES 分布式搜索引擎作为复杂查询的加速器，对于 缓存不可靠 如何处理

2. 数据不一致问题

   

3. 审批流程异步化

   - 负责使用 base 框架 来做异步化
   - 学习了他们如何设计的这个异步框架
   - 如何利用 AOP， 利用 Spring 的扩展点



## 自动验收项目





