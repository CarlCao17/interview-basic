# 第三章 垃圾收集器与内存分配策略

## 一、 如何判断对象的存活情况

1. 引用计数法：每个对象都有一个引用计数变量，如果一个对象新指向它，引用计数加一，反之减一，如果计数变量为0，则可以回收。**存在循环引用的问题**

2. 可达性分析：从"GCRoots"对象出发，可以抵达的对象形成一条链“可达链”，如果对象不可达则可以回收

   GCRoots对象：

   - 虚拟机栈中引用的对象
   - 方法区中类静态域引用的对象
   - 方法区中常量引用的对象
   - 本地方法栈中JNI引用的对象

3. 引用类型——引用强度依次递减
   - 强引用： `String a = new String("123");`
   - 软引用: 那些还有用但是非必须的对象，软引用关联的对象，在系统即将发生内存溢出异常之前，将会被回收，如果回收之后内存还不够，将会抛出OOM，对应`SoftReference`类
   - 弱引用: 同样非必须的对象，但弱引用关联的对象，只能存活到下次GC之前，如`ThreadLocal`的键，对应`WeakReference`类
   - 虚引用（也叫幽灵引用）：一个对象是否有虚引用对其生命周期没有任何影响。为一个对象设置虚引用的唯一目的的是在这个对象被垃圾收集器回收时收到一个系统通知，对应`PhantomReference`类
4. 对象的死亡过程
5. 回收方法区
   - 常量
   - 类



## 二、垃圾收集算法

1. 标记清除算法：有两个问题——效率问题和空间碎片问题
2. 复制算法：（分半）复制，适用于大部分对象都会被回收的情况。新生代一般用这个，但一般 Eden 80% + from 10% + to %。如果存活率较高，需要较多的复制操作，效率变低
3. 标记整理算法：先标记，然后让存活的对象全部移动到一端，然后清理掉边界以外的内存
4. 分代收集算法：将堆分为新生代和老年代，新生代存活率低使用复制算法，老年代存活率高，没有额外空间为它进行担保，使用“标记-清理”或“标记-整理“算法。

## 三、垃圾收集器

新生代：

- Serial 收集器，单线程 + Stop the world， **新生代使用复制算法，老年代使用标记-整理算法**，是Client模式下默认新生代收集器，在单CPU的环境下，几乎可以得到最高的单线程收集效率

- ParNew收集器，基本上就是 Serial收集器的多线程版本，其他的如控制参数、收集算法、Stop the World、对象分配规则、回收策略等都和Serial完全一样，是Server模式下的首选的新生代垃圾收集器

   `-XX:+UseParNewGC`强制使用，或者`-XX:UseConcMarkSweepGC`的默认新生代垃圾收集器

  在多线程环境下可以提高系统资源的有效利用率，可以使用-XX:ParallelGCThreads限制垃圾收集器的线程数

- ParallelScavenge垃圾收集器：复制算法， 吞吐量优先，可以使用 `-XX:MaxGCPauseMillis`控制最大垃圾收集停顿时间，`-XX:GCTimeRatio`参数指定吞吐量，`-XX:UseAdaptiveSizePolicy`参数打开之后就不需要手动指定新生代的大小(`-Xmn`)、Eden区与Survisor区的比例(`-XXSurvivorRatio`)、晋升老年代对象大小(`-XX:PretenureSizeThreshold`)等细节，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量——这种调节方式叫做GC自适应的调节策略。

- SerialOld算法，多线程 + 标记整理算法那，Serial收集器的老年代，要么和ParallelScanvenge配合，或者作为CMS的后备，适合Client端

- ParallelOld: 多线程 + 标记整理算法，Parallel Scavenge的老年代算法，在注重吞吐量 以及CPU资源紧张的场合，可以优先考虑Parallel Scanvage + Parallel Old

- **CMS 算法—— Concurrent Mark Sweep**： 以获取最短回收停顿时间为目标的收集器

  - 初始标记，Stop the world，只标记和GCRoots直接关联到的对象
  - 并发标记，并发地 进行 可达性分析
  - 重新标记， Stop the world，修正并发标记期间因应用程序继续运作而导致标记发生变动的那一部分对象的标记记录
  - 并发清除，并发地清除

  主要缺点：

  - 对CPU资源很敏感
  - 无法处理浮动垃圾
  - 